3 fonctions ont été codées afin de pouvoir analyser la bibliothèque USBctrl et le driver USB High Speed avec EVA:
\begin{itemize}
    \item test\_fcn\_usbctrl : analyse des fonctions de bibliothèque USBctrl dans leur comportement nominal:
    	\begin{itemize}
    		\item initialisation des paramètres d'entrée des différentes fonctions de la bibliothèques USBctrl à l'aide de la fonction de Frama-C Frama\_C\_interval,
    		\item déclaration de deux contextes USB, de plusieurs interfaces USB,
    		\item appel des fonctions de gestion des événements et des requètes.
    	\end{itemize}
    \item test\_fcn\_usbctrl\_erreur : vérification de la gestion d'erreurs implémentée dans la bibliothèque USBctrl, avec des paramètres d'entrée invalides (pointeurs null par exemple, ou dépassant une valeur maximale...),
    \item test\_fcn\_driver\_eva: analyse de la gestion d'erreur des fonctions du driver et analyse des fonctions du driver USB High Speed qui ne sont pas directement appelées par la bibliothèque USBctrl et test
\end{itemize}

\begin{lstlisting}[style=CStyle]
void test_fcn_usbctrl(){

    uint32_t dev_id = Frama_C_interval(0,65535) ;
    uint32_t size = Frama_C_interval(0,65535) ;
    uint32_t handler ;
    uint8_t ep = Frama_C_interval(0,255);
    uint8_t iface = Frama_C_interval(0,MAX_INTERFACES_PER_DEVICE-1);
    uint8_t ep_number = Frama_C_interval(0,MAX_EP_PER_INTERFACE);
    uint8_t EP_type = Frama_C_interval(0,3);
    uint8_t EP_dir = Frama_C_interval(0,1);
    uint8_t USB_class = Frama_C_interval(0,17);
    uint32_t USBdci_handler = Frama_C_interval(0,65535) ;
    usb_device_trans_t transition = Frama_C_interval(0,MAX_TRANSITION_STATE-1) ;
    usb_device_state_t current_state = Frama_C_interval(0,9);
    usbctrl_request_code_t request = Frama_C_interval(0x0,0xc);

    uint8_t RequestType = Frama_C_interval(0,255);
    uint8_t Request = Frama_C_interval(0,0xd);
    uint16_t Value = Frama_C_interval(0,65535);
    uint16_t Index = Frama_C_interval(0,65535);
    uint16_t Length = Frama_C_interval(0,65535);

    usbctrl_interface_t iface_1 =
    { .usb_class = USB_class, .usb_ep_number = ep_number, .dedicated = true,
    .eps[0].type = EP_type, .eps[0].dir = EP_dir, .eps[0].handler = handler_ep,
    .rqst_handler = class_rqst_handler, .class_desc_handler = class_get_descriptor};

    usbctrl_interface_t iface_2 =
    { .usb_class = USB_class, .usb_ep_number = ep_number, .dedicated = true,
    .eps[0].type = EP_type, .eps[0].dir = EP_dir, .eps[0].handler = handler_ep,
    .rqst_handler = class_rqst_handler, .class_desc_handler = class_get_descriptor};

    usbctrl_interface_t iface_3 =
    { .usb_class = USB_class, .usb_ep_number = ep_number, .dedicated = false,
    .eps[0].type = EP_type, .eps[0].dir = EP_dir, .eps[0].handler = handler_ep};

    usbctrl_setup_pkt_t pkt =
    { .bmRequestType = RequestType, .bRequest = Request, .wValue = Value,
      .wIndex = Index, .wLength = Length };


    usbctrl_context_t *ctx1 = NULL;
    usbctrl_context_t *ctx2 = NULL;
    uint32_t ctxh1=0;
    uint32_t ctxh2=0;

    ///////////////////////////////////////////////////
    //        premier context
    ///////////////////////////////////////////////////

    usbctrl_declare(6, &ctxh1);
    usbctrl_initialize(ctxh1);
    usbctrl_get_context(6, &ctx1);
    usbctrl_declare_interface(ctxh1, &iface_1) ;
    usbctrl_declare_interface(ctxh1, &iface_2);
    usbctrl_declare_interface(ctxh1, &iface_3);
    usbctrl_get_interface(ctx1, iface);
    usbctrl_get_handler(ctx1, &handler);
    usbctrl_is_interface_exists(ctx1, iface);
    usbctrl_is_endpoint_exists(ctx1, ep);
    usbctrl_start_device(ctxh1) ;
    usbctrl_stop_device(ctxh1) ;

    if(ctx1 != NULL){
        ctx1->state = Frama_C_interval(0,9);
            usbctrl_is_valid_transition(ctx1->state,transition,ctx1);
            usbctrl_handle_class_requests(&pkt,ctx1) ;
    }

    ///////////////////////////////////////////////////
    //        2nd context
    ///////////////////////////////////////////////////

    usbctrl_declare(7, &ctxh2);
    usbctrl_initialize(ctxh2);
    usbctrl_get_handler(&ctx_test, &handler);
    usbctrl_get_context(7, &ctx2);
    usbctrl_get_handler(ctx2, &handler);
    usbctrl_declare_interface(ctxh2, &iface_1) ;
    usbctrl_declare_interface(ctxh2, &iface_2);
    usbctrl_declare_interface(ctxh2, &iface_3);
    usbctrl_get_interface(ctx2, iface);
    usbctrl_is_interface_exists(ctx2, iface);
    usbctrl_is_endpoint_exists(ctx2, ep);
    usbctrl_start_device(ctxh2) ;
    usb_device_state_t state = usbctrl_get_state(ctx2);
    usbctrl_stop_device(ctxh2) ;

    if(ctx2 != NULL){
        ctx2->state = Frama_C_interval(0,9);
        usbctrl_is_valid_transition(ctx2->state,transition,ctx2);
        usbctrl_handle_class_requests(&pkt,ctx2) ;
    }

    //////////////////////////////////////////////////////////////////////////////
    //        fonctions qui vont utiliser les deux contextes (inepevent et outepevent)
    //////////////////////////////////////////////////////////////////////////////

    ctx_list[0].ctrl_req_processing = true;
    usbctrl_handle_inepevent(dev_id, size, ep);
    usbotghs_ctx.out_eps[0].state = Frama_C_interval(0,9);
    usbctrl_handle_outepevent(dev_id, size, ep);
    usbctrl_handle_earlysuspend(dev_id) ;
    usbctrl_handle_usbsuspend(dev_id);
    usbctrl_handle_wakeup(dev_id) ;
    usbctrl_std_req_get_dir(&pkt) ;
    usbctrl_handle_reset(dev_id);
    usbctrl_next_state(current_state,request);
	usbctrl_handle_requests(&pkt, dev_id) ;
    usbctrl_handle_requests_switch(&pkt, dev_id) ;

}
\end{lstlisting}


\begin{lstlisting}[style=CStyle]
void test_fcn_usbctrl_erreur(){

    uint32_t dev_id = Frama_C_interval(0,RAND_UINT_32-1) ;
    uint32_t size = Frama_C_interval(0,RAND_UINT_32-1) ;
    uint32_t ctxh = Frama_C_interval(0,MAX_USB_CTRL_CTX-1);
    uint32_t handler = Frama_C_interval(0,RAND_UINT_32-1);
    uint8_t ep = Frama_C_interval(0,255);
    uint8_t iface = Frama_C_interval(0,MAX_INTERFACES_PER_DEVICE-1);
    uint8_t ep_number = Frama_C_interval(0,MAX_EP_PER_INTERFACE);
    uint8_t EP_type = Frama_C_interval(0,3);
    uint8_t EP_dir = Frama_C_interval(0,1);
    uint8_t  USB_class = Frama_C_interval(0,17);
    uint32_t USBdci_handler = Frama_C_interval(0,RAND_UINT_32-1) ;


    uint8_t RequestType = Frama_C_interval(0,255);
    uint8_t Request = Frama_C_interval(0,255);
    uint16_t Value = Frama_C_interval(0,65535);
    uint16_t Index = Frama_C_interval(0,65535);
    uint16_t Length = Frama_C_interval(0,65535);

    usbctrl_setup_pkt_t pkt =
    { .bmRequestType = RequestType, .bRequest = Request, .wValue = Value,
     .wIndex = Index, .wLength = Length };
    usbctrl_interface_t iface_1 =
    { .usb_class = USB_class, .usb_ep_number = ep_number, .dedicated = true,
    .eps[0].type = EP_type, .eps[0].dir = EP_dir, .eps[0].handler = NULL,
    .rqst_handler = NULL, .class_desc_handler = NULL};
    usbctrl_interface_t iface_2 =
    { .usb_class = USB_class, .usb_ep_number = ep_number, .dedicated = true,
    .eps[0].type = EP_type, .eps[0].dir = EP_dir, .eps[0].handler = NULL,
    .rqst_handler = NULL, .class_desc_handler = NULL};

    usbctrl_context_t ctx_test = { .dev_id = 8, .address= 2};

    /*
        usbctrl_declare : cas d'erreur - pointeur ctxh null
                                       - num_ctx >= 2
    */

    uint32_t *bad_ctxh = NULL;
    usbctrl_declare(dev_id, bad_ctxh);

    ctxh = 1 ;
    num_ctx = 2;
    //@ ghost GHOST_num_ctx = num_ctx ;
    usbctrl_declare(dev_id, &ctxh);



    /*
        usbctrl_declare : cas d'erreur : ctxh >= num_ctx
    */

    ctxh = 0 ;
    num_ctx = 1 ;
    usbctrl_initialize(ctxh);


    ctxh = 1 ;
    num_ctx = 0 ;
    //@ ghost  GHOST_num_ctx = num_ctx ;
    usbctrl_declare(8, &ctxh);
    usbctrl_initialize(ctxh);

    /*
        usbctrl_declare_interface : cas d'erreur - ctxh >= num_ctx
                                                 - pointeur iface == null
                                                 - interface_num >= MAX_INTERFACES_PER_DEVICE
                                                 - pkt_maxsize > usbotghs_get_ep_mpsize()
        Dans le cas nominal, avec le test sur 2 interfaces, num_cfg >= MAX_USB_CTRL_CTX-1
        donc une partie du code n'est pas atteinte. Cas traite ci-dessous, quand on
        rajoute une interface de controle
    */


    ctxh = 2 ;
    num_ctx = 1 ;
    //@ ghost  GHOST_num_ctx = num_ctx ;
    usbctrl_declare_interface(ctxh, &iface_1) ;

    ctxh = 0 ;
    num_ctx = 1 ;
    usbctrl_interface_t *iface_null = NULL ;
    usbctrl_declare_interface(ctxh, iface_null) ;

    usbctrl_interface_t iface_3 =
    {.usb_class = 0, .usb_ep_number = 2, .dedicated = true, .eps[0].type = 3,
     .eps[0].pkt_maxsize = MAX_EPx_PKT_SIZE + 1 };
    ctx_list[ctxh].cfg[0].interface_num = MAX_INTERFACES_PER_DEVICE ;
    usbctrl_declare_interface(ctxh, &iface_3) ;

    usbctrl_interface_t iface_4 =
    {.usb_class = 0, .usb_ep_number = 2, .dedicated = false, .eps[0].type = 3,
     .eps[0].pkt_maxsize = MAX_EPx_PKT_SIZE + 1 };
    ctx_list[ctxh].cfg[0].interface_num = MAX_INTERFACES_PER_DEVICE - 1 ;
    //ctx_list[ctxh].cfg[0].interfaces[0].eps[0].pkt_maxsize = MAX_EPx_PKT_SIZE + 1 ;
    usbctrl_declare_interface(ctxh, &iface_4) ;

    //ctx_list[ctxh].cfg[0].interface_num = MAX_INTERFACES_PER_DEVICE - 1 ;
    //ctx_list[ctxh].num_cfg < MAX_USB_CTRL_CTX -1  ;
    //usbctrl_declare_interface(ctxh, &iface_3) ;

    /*
        usbctrl_get_interface : cas d'erreur - pointeur ctx null
        cas iface < ctx->cfg[ctx->curr_cfg].interface_num pas atteint dans le cas nominal
    */
    usbctrl_context_t *bad_ctx = NULL ;
    usbctrl_get_interface(bad_ctx, iface);

    ctx_list[ctxh].cfg[0].interface_num = MAX_INTERFACES_PER_DEVICE ;
    usbctrl_get_interface((usbctrl_context_t *)&(ctx_list[ctxh]), iface);

    /*
        usbctrl_get_handler: cas d'erreur -  pointeur ctx null
                                           - pointeur handler null
                                           - context different de ctx_list,
                                           pour trigger certains cas dans get_handler
        comme num_ctx < MAX_USB_CTRL_CTX pour ne pas avoir de debordement de tableau
        la boucle n'est parcourue qu'une fois dans la fonction
    */

    usbctrl_get_handler(bad_ctx, &handler);
    usbctrl_get_handler(&ctx_test, &handler);  // pour tester behavior not_found


    /*
        usbctrl_get_context, usbctrl_is_endpoint_exists &&  usbctrl_is_interface_exists:
         cas d'erreur - pointeur ctx null
    */

    usbctrl_get_context(dev_id,     NULL);
    usbctrl_is_endpoint_exists(bad_ctx, ep);
    usbctrl_is_interface_exists(bad_ctx, iface);

    /*
        test erreur avec un numero de ctx >= num_ctx (qui vaut 1 au max dans mon cas,
        avec un max de cfg de 2)
    */

    usbctrl_start_device(4) ;
    usbctrl_stop_device(4) ;

    /*
        test erreur sur get_descriptor : parcourir tous les types possibles,
        incluant un faux type
            pointeurs null
            ctx != ctx_list[i] pour error_not_found dans get_handler
            class_get_descriptor : error_none forcement,donc je ne rentre pas dans
            errcode != error_none
    */

    uint8_t buf[255] = {0} ;
    uint32_t desc_size = 0 ;
    usbctrl_context_t ctx1 = {1} ;

    usbctrl_get_descriptor(9,&buf[0],&desc_size,&ctx1, &pkt);
    usbctrl_get_descriptor(USB_DESC_DEV_QUALIFIER,&buf[0],&desc_size,&ctx1, &pkt);
    usbctrl_get_descriptor(USB_DESC_OTHER_SPEED_CFG,&buf[0],&desc_size,&ctx1, &pkt);
    usbctrl_get_descriptor(USB_DESC_IFACE_POWER,&buf[0],&desc_size,&ctx1, &pkt);
    usbctrl_get_descriptor(1,NULL,&desc_size,&ctx1, &pkt);
    usbctrl_get_descriptor(1,&buf[0],NULL,&ctx1, &pkt);
    usbctrl_get_descriptor(1,&buf[0],&desc_size,NULL, &pkt);
    usbctrl_get_descriptor(1,&buf[0],&desc_size,&ctx1, NULL);

    usbctrl_get_state(NULL) ;
    usbctrl_set_state(&ctx1,10);
    usbctrl_set_state(NULL,10);

	usbctrl_context_t ctx2 = ctx_list[0] ;
	ctx2.state = Frama_C_interval(0,9);
	usbctrl_handle_class_requests(&pkt, &ctx2);

	usbctrl_handle_requests(NULL, dev_id);
}
\end{lstlisting}

\begin{lstlisting}[style=CStyle]
void test_fcn_driver_eva(){

    uint8_t ep_id = Frama_C_interval(0,255);
    uint8_t ep_num = Frama_C_interval(0,255);
    uint8_t dir8 = Frama_C_interval(0,255);
    uint8_t dst = Frama_C_interval(0,255);
    uint32_t size = Frama_C_interval(0,65534);
    uint8_t fifo = Frama_C_interval(0,255);
    uint32_t fifo_idx = Frama_C_interval(0,65535);
    uint32_t fifo_size = Frama_C_interval(0,65535);

    uint8_t src = 1 ;

    usbotghs_ep_dir_t dir = Frama_C_interval(0,1);
    usbotghs_ep_type_t type = Frama_C_interval(0,3);
    usbotghs_ep_state_t state = Frama_C_interval(0,9) ;

    usbotghs_global_stall() ;
    usbotghs_endpoint_set_nak(ep_id, dir) ;
    usbotghs_global_stall_clear();
    usbotghs_endpoint_stall_clear(ep_id, dir);
    usbotghs_deconfigure_endpoint(ep_id);
    usbotghs_activate_endpoint(dir8,dir);
    usbotghs_deactivate_endpoint( ep_id,dir);
    usbotghs_enpoint_nak( ep_id);
    usbotghs_enpoint_nak_clear( ep_id);
    usbotghs_endpoint_disable( ep_id, dir);
    usbotghs_endpoint_enable( ep_id, dir);
	usbotghs_endpoint_clear_nak(ep_id, dir) ;
    usbotghs_endpoint_stall(ep_id, dir) ;
    usbotghs_get_ep_state(ep_id, dir) ;

    uint8_t resp[1024] = { 0 };
    usbotghs_send_zlp(ep_id);
    usbotghs_txfifo_flush(ep_id);
	usb_backend_drv_configure_endpoint(ep_id,type,dir,size,USB_BACKEND_EP_ODDFRAME,&handler_ep);
}
\end{lstlisting}