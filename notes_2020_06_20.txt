commande pour parser rapidement le fichier de log EVA :
grep 'rte,unsigned_downcast' frama-c-rte-eva.log | grep -v 'got final status valid' & grep "'rte,index_bound' got status unknown" frama-c-rte-eva.log & grep 'rte,mem_access' frama-c-rte-eva.log | grep -v 'got final status valid'


- Création d'un seul fichier .c concaténant tous les fichiers .c de la lib xDCI
- Modification du makefile avec ajout de 3 règles (ajout -concat aux 3 autres règles) pour juste prendre en entrée le fichier unique et le driver
- Modification du point d'entrée avec EVA pour analyser toutes les fonctions de la libxDCI et toutes les fonctions du driver (ajout d'une fonction test_eva dans usbotghs_frama.c) (avec le maximum de couverture pour ces fonctions)

Résulats obtenus avec EVA : il reste 3 RTE sur la libxDCI

	- usbctrl_handle_class_requests : iface_idx = (((pkt->wIndex) & 0xff) - 1);  
			rte unsigned downcast unknow pour EVA
			iface_idx doit valoir 0 ou 1 normallement ? pkt->wIndex uint16_t, 0xff = 255
            faux positif avec EVA si Index > 0 ... (la comparaison avec 0x255 va forcement >= 1 ...) j'ai choisi de faire varier pkt->WIndex de 0 à 65535 (pas de raison pour ne pas considérer 0, mais c'est le cas qui pose pb pour iface_idx : 0 - 1 < 0)



    - usbctrl_get_descriptor:
            uint8_t compteur_poll = 9;
            while (!(poll & 0x1) || compteur_poll > 0) {
            poll >>= 1;
            i++;
            compteur_poll -- ;  // cyril : faux positif avec EVA, qui n'arrive pas à vérifier que compteur_poll >= 0 (ça passe avec wp)

    - usbctrl_handle_requests :
    		 ctx->ctrl_fifo_state = USB_CTRL_RCV_FIFO_SATE_FREE;   // Cyril : probleme ici, on peut y arriver avec ctx non défini (donc accès mémoire invalide)
    		 bug dejà signalé, j'attends de voir avec Philippe quoi faire

Les autres bugs ont été corrigés (déjà signalés auparavant, voir // Cyril pour les voir)

Pour la libxDCI, quasiment 100% de taux de couverture sauf : certains case default dans les switch, impossible à atteindre car test avant le switch qui éliminent les case default

dès cas d'erreur qui nécessitent ctx null par exemple, mais comme la fonction nécessite valid(ctx), je ne sais pas si je peux faire ctx == null pour ces fonctions

dans std_req_handle_get_descriptor : bcp de tests if (maxlength == 0) qui ne peuvent pas être vrais, car dès le début de la fonction le cas maxlength == 0 est éliminé
question à poser : à quoi servent ces tests du coup?

Pour les fonctions du driver : ajout de la fonction test_fcn_driver_eva pour appeler les fonctions du driver et les analyser avec EVA (toutes les fonctions ne sont pas appelées avec la libxDCI, mais je pense que c'est mieux de vérifier l'absence de RTE sur le driver (ou en tout cas un bon niveau de confiance sur l'absence de RTE))

RTE découverts :

	- usbotghs_deconfigure_endpoint : if (ctx->in_eps[ep].configured  == true) et (ctx->out_eps[ep].configured == true)
	il n'y a pas de tests sur ep, donc risque de dépassement de tableau  /*@ assert rte: index_bound: ep < 3; */ et  /*@ assert rte: index_bound: ep < 8; */


	 - usbotghs_send_data et usbotghs_set_recv_fifo : taux de couverture faible, donc tentative d'augmenter le taux de couverture de ces fonctions en les appelant dans test_fcn_driver_eva
	 problème : pour améliorer le taux de couverture, j'ai du spécifier usbotghs_ctx.out_eps[0] avec des framaC interval
	 et j'ai des problèmes de précisions avec le message suivant : (pour ep->mpsize) 
	 ep->mpsize -> {{ garbled mix of &{usbctrl_handle_outepevent; handler_ep; ctx_list}
		(origin: Misaligned) }}
	donc dès que ep->mpsize est utilisé dans ces fonctions, EVA n'arrive plus à vérifier grand chose...

	    /*@ assert rte: signed_overflow: -2147483648 ≤ (int)ep->mpsize - 1; */
    /*@ assert rte: unsigned_downcast: (int)ep->mpsize - 1 ≤ 4294967295; */
    /*@ assert rte: unsigned_downcast: 0 ≤ (int)ep->mpsize - 1; */
    /*@ assert Eva: signed_overflow: (int)ep->mpsize - 1 ≤ 2147483647; */
    /*@ assert rte: division_by_zero: (unsigned int)ep->mpsize ≢ 0; */
    (pour set_recv_fifo par exemple)
    uint32_t pktcount = size / ep->mpsize + (size & (ep->mpsize - 1) ? 1: 0);


- pour set_recv_fifo: appelé notamment par start device, à voir si je peux jouer sur ça pour parcourir plus de cas dans set_recv_fifo


 si j'enleve l'appel à set_recv_fifo et send_data dans la fonction test_fcn_driver_eva, il ne reste que le probleme de usbotghs_deconfigure_endpoint
 mais la couverture des fonctions usbotghs_send_data et usbotghs_set_recv_fifo est faible


 Résultat WP : 

 - pour le driver : 

 send_data continue à poser des pb pour les assigns. C'est la dernière fonction que je ne parviens par à spécifier correctement (parmi les fonctions appelées par la lib USB)

 - set_adress : depend set_reg, il manque le cas avec un mask != 0xffffff, je n'arrive pas à la prouver dans set_reg_value...



 - pour la lib USB

 - modification des spec de usbctrl_get_state (le ensures is_valid_state n'était pas nécessaire, et du coup 3 fonctions ne passaient pas 
 (is_valid_class_request et les deux autres pareil)) : maintenant tout est ok

 - usbctrl_declare : assigns ne passe pas car la fonction appelle usbotghs_declare qui assign usbotghs_ctx qui est static (à voir comment arranger ça avec un ghost)

 - usbctrl_declare_interface : l'appel à la fonction usb_backend_get_ep_mpsize, donc à usbotghs_get_ep_mpsize, dans la boucle fait que le assigns ne passe pas...(pour behavior_ok). Test fait en supprimant l'appel à cette fonction, tout est validé avec WP.
Même ave un separated (mais separated et assigns \nothing, je sais pas trop quoi mettre), ça ne passe pas

 - usbctrl_get_descriptor : 

    1 problemes pour finir de spécifier la fonction:  cast du type : usbctrl_device_descriptor_t *desc = (usbctrl_device_descriptor_t*)buf;  
                            desc->bLength = sizeof(usbctrl_device_descriptor_t);
            wp est perdu, assigns *buf ne passe pas (en même temps, buf est de type uin8_t *...)
    un bug :   uint32_t max_buf_size = *desc_size - curr_offset
                *desc_size quand on arrive ici vaut 0... alors que curr_offset >0
                probleme pour EVA  assert rte: unsigned_overflow: 0 ≤ *desc_size - curr_offset;
    pour le compteur poll, eva n'arrive pas à prouver qu'il reste >= 0
    les loop assigns ne passent pas également (pb de cast tjrs)

    La spécification sans les assign passe



usbctrl_std_req_handle_get_status : ok sans les assigns (voir si separated aide)


usbctrl_std_req_handle_set_address : spec ok, ajout de \separated important pour que ça passe !!


usbctrl_std_req_handle_get_configuration : les assigns ne passent pas car pas de spec definitive dans send_data
											voir pour ajout de \separated quand des appels aux fonctions du driver sont faits
											sinon la spec est ok (completed / disjoint)

usbctrl_std_req_handle_set_configuration : spec à travailler, sans les assigns d'abord
		pour correctement spécifier la boucle, je dois gerer GHOST_usbotghs_ctx (usbotghs_ctx est une variable static) (appel à usb_backend_drv_configure_endpoint dans la boucle)
		autre pb :  requested_configuration = pkt->wValue;  //Cyril : Problème ici: pkt->wValue est un uint16_t, alors que requested_configuration est un uint8_t  (pb EVA)


usbctrl_handle_requests : le comportement unknown ne passe pas (ensure non prouvé), le disjoint non plus, je ne comprends pas pq. Ajout d'assert dans toute la fonction pour aider wp, ils sont prouvés, mais ça ne suffit pas (timeout 2min pour essayer de prouver un ensure et le disjoint). Ok pour complete behaviors
pas encore mis les assigns


usbctrl_std_req_handle_get_descriptor : spec à travailler, mais comme elle dépend de send_data, je ne peux pas spécificer les assign. Très nombreux appels aux fonctions du driver, donc voir pour ajouter des \separated un peu partout
Cyril : buf doit être initialisé (bug eva)
meme sans les assigns, completed ne passe pas encore, ainsi que 2 comportements

usbctrl_std_req_handle_set_descriptor : ok (meme avec les assigns)

usbctrl_std_req_handle_set_feature : ok (meme avec les assigns)


usbctrl_std_req_handle_set_interface :  ok (meme avec les assigns)

usbctrl_std_req_handle_synch_frame : ok (meme avec les assigns)


usbctrl_handle_std_requests : spec à travailleur, quasiment la dernière à spec car elle fait appel à presque toutes les autres fonctions handle

usbctrl_handle_class_requests : la spec est correcte, reste un pb sur iface_idx à régler (la spec ne passe pas si le pb n'est pas réglé)

usbctrl_handle_reset : spec à travailler, 


usbctrl_handle_inepevent : spec validée, malgré l'appel à get_context (marche car fichier unique...)
à revoir si je re sépare les fichiers (pb du num_ctx static)


usbctrl_handle_outepevent : fonction compliquée à spécifier
probleme, je dois faire référence à usbotghs_ctx.in_eps[epnum].state pour les différents comportements. Mais usbotghs_ctx est une variable static pour usbotghs...
tentative avec GHOST_usbotghs_ctx->out_eps[ep].state, ça ne marche pas
comment parcourir la fonction avec plusieurs états?  le driver est dans l'état IDLE, je ne sais pas comment le forcer à changer d'état (tentative avec framac interval, mais bcp d'effets indésirables sur d'autres fonctions... + pb de garbled mix)
en fait, ça dépend du matériel pour les états d'appels à outepevent : idée faire une "fausse fonction get_ep_state" avec eva use spec (je fais pas une fonction, je fais une spec)

