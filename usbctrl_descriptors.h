/*
 *
 * Copyright 2018 The wookey project team <wookey@ssi.gouv.fr>
 *   - Ryad     Benadjila
 *   - Arnauld  Michelizza
 *   - Mathieu  Renard
 *   - Philippe Thierry
 *   - Philippe Trebuchet
 *
 * This package is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * the Free Software Foundation; either version 2.1 of the License, or (at
 * ur option) any later version.
 *
 * This package is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along
 * with this package; if not, write to the Free Software Foundation, Inc., 51
 * Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 *
 */
#ifndef USB_CTRL_DESCRIPTORS_H_
#define USB_CTRL_DESCRIPTORS_H_


/*
 * This is the central USB control descriptors configuration and description.
 *
 * USB descriptors types are declared here and generated by the libusbctrl based on
 * the various informations declared by the upper libraries (libbulk, libhid,
 * libscsi...) in order to declare the device personality to the host.
 *
 * EP identifiers are generated depending on the personality declaration order.
 */

/*
 * Global device descriptor. This descriptor is unique for the entire device,
 * even in case of hybrid (multi-personality) device.
 */
typedef struct __packed usb_ctrl_device_descriptor {
	uint8_t  bLength;
	uint8_t  bDescriptorType;
	uint16_t bcdUSB;
	uint8_t  bDeviceClass;
	uint8_t  bDeviceSubClass;
	uint8_t  bDeviceProtocol;
	uint8_t  bMaxPacketSize;
	uint16_t idVendor;
	uint16_t idProduct;
	uint16_t bcdDevice;
	uint8_t  iManufacturer;
	uint8_t  iProduct;
	uint8_t  iSerialNumber;
	uint8_t  bNumConfigurations;
} usb_ctrl_device_descriptor_t;

/*
 * USB configuration descriptor. Global to the device, specify the
 * device configuration (number of interfaces, power, ...)
 */
typedef struct __packed usb_ctrl_configuration_descriptor {
	uint8_t bLength;
	uint8_t bDescriptorType;
	uint16_t wTotalLength;
	uint8_t bNumInterfaces;
	uint8_t bConfigurationValue;
	uint8_t iConfiguration;
	struct {
		uint8_t reserved:5;
		uint8_t remote_wakeup:1;
		uint8_t self_powered:1;
		uint8_t reserved7:1;
	} bmAttributes;
	uint8_t bMaxPower;
} usb_ctrl_configuration_descriptor_t;

/**
 * Interface descriptor set,
 */
typedef struct __packed usb_ctrl_interface_descriptor {
	uint8_t bLength;
	uint8_t bDescriptorType;
	uint8_t bInterfaceNumber;
	uint8_t bAlternateSetting;
	uint8_t bNumEndpoints;
	uint8_t bInterfaceClass;
	uint8_t bInterfaceSubClass;
	uint8_t bInterfaceProtocol;
	uint8_t iInterface;
} usb_ctrl_interface_descriptor_t;

/**
 * Endpoint descriptor set for run-time mode (only?).
 */
typedef struct __packed usb_ctrl_endpoint_descriptor {
	uint8_t bLength;
	uint8_t bDescriptorType;
	uint8_t bEndpointAddress;
    uint8_t bmAttributes;
/*	struct {
		uint8_t transfer_type:2;
		uint8_t iso_synchro_type:2;
		uint8_t iso_usage_type:2;
		uint8_t reserved:2;
	} bmAttributes;
*/
	uint16_t wMaxPacketSize;
	uint8_t bInterval;

} usb_ctrl_endpoint_descriptor_t;


typedef struct __packed usb_ctr_full_endpoint_descriptor {
	usb_ctrl_endpoint_descriptor_t ep_in;
	usb_ctrl_endpoint_descriptor_t ep_out;
} usb_ctr_full_endpoint_descriptor_t;

/*
 * FIXME: this DFU functional descriptor should be handled at DFU level (not here)
 */
typedef struct __packed usb_functional_descriptor {
    uint8_t bLength;
    uint8_t bDescriptorType;
    struct {
        uint8_t bitCanDnload:1;
        uint8_t bitCanUpload:1;
        uint8_t bitManifestationTolerant:1;
        uint8_t bitWillDetach:1;
        uint8_t reserved:4;
    } bmAttributes;
    uint16_t wDetachTimeOut;
    uint16_t wTransferSize;
    uint16_t bcdDFUVersion;
} usb_dfu_functional_descriptor_t;

typedef struct __packed usb_ctrl_full_configuration_descriptor {
	usb_ctrl_configuration_descriptor_t config_desc;
    /*  Each interfaces if followed by its endpoints configuration
     *  FIXME We only support one interface per configuration
     */
	usb_ctrl_interface_descriptor_t interface_desc;
	union {
		usb_ctr_full_endpoint_descriptor_t ep;
		usb_functional_descriptor_t functional_desc;
	};
} usb_ctrl_full_configuration_descriptor_t;


/**
 * \brief String descriptor.
 */
typedef struct __packed usb_string_descriptor {
	uint8_t bLength;
	uint8_t bDescriptorType;
	uint16_t wString[MAX_DESC_STRING_SIZE];
} usb_string_descriptor_t;

#endif/*!USB_CTRL_DESCRIPTORS_H_*/
